---
phase: 02-ai-coaching-loop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/server/db/schema.ts
  - src/server/lib/coaching.ts
  - src/server/lib/guardrails.ts
  - src/server/routes/chat.ts
  - src/server/routes/profile.ts
  - src/server/index.ts
  - src/client/hooks/useChat.ts
  - src/client/components/Chat.tsx
  - src/client/components/ChatMessage.tsx
  - src/client/styles/global.css
  - src/client/App.tsx
  - src/client/main.tsx
autonomous: true

must_haves:
  truths:
    - "User can type a message, send it, and see a streaming AI response appear word-by-word"
    - "Chat messages persist across page refresh (stored in database)"
    - "AI coach has access to coaching profile and recent workouts in its system prompt"
    - "User can generate a structured workout via explicit action and it saves to the database"
    - "User can log completed sets via freeform text and it parses into structured data"
  artifacts:
    - path: "src/server/db/schema.ts"
      provides: "messages, coachingProfiles tables + restSeconds column"
      contains: "messages"
    - path: "src/server/lib/coaching.ts"
      provides: "System prompt builder with profile + recent workouts"
      exports: ["buildSystemPrompt"]
    - path: "src/server/lib/guardrails.ts"
      provides: "Weight validation against known maxes"
      exports: ["validateWorkoutWeights"]
    - path: "src/server/routes/chat.ts"
      provides: "POST /api/chat/send (SSE streaming), POST /api/chat/generate-workout, POST /api/chat/history"
    - path: "src/server/routes/profile.ts"
      provides: "GET /api/profile, PUT /api/profile"
    - path: "src/client/hooks/useChat.ts"
      provides: "useChat hook consuming SSE stream"
    - path: "src/client/components/Chat.tsx"
      provides: "Chat message list + input bar"
    - path: "src/client/styles/global.css"
      provides: "Mobile-first dark theme CSS variables and base styles"
  key_links:
    - from: "src/client/hooks/useChat.ts"
      to: "/api/chat/send"
      via: "fetch POST with ReadableStream SSE consumer"
      pattern: "fetch.*api/chat/send"
    - from: "src/server/routes/chat.ts"
      to: "src/server/lib/coaching.ts"
      via: "buildSystemPrompt() called before Gemini chat"
      pattern: "buildSystemPrompt"
    - from: "src/server/routes/chat.ts"
      to: "src/server/db/schema.ts"
      via: "messages table insert after each exchange"
      pattern: "insert.*messages"
    - from: "src/client/components/Chat.tsx"
      to: "src/client/hooks/useChat.ts"
      via: "hook provides messages, sendMessage, isStreaming"
      pattern: "useChat"
---

<objective>
Build the complete chat interface and all backend API routes for the AI coaching loop. This includes database schema changes, server-side coaching intelligence (system prompt builder, weight guardrails), all API endpoints (chat streaming, workout generation, freeform logging, profile management), and the React chat UI with SSE streaming.

Purpose: This is the core of Phase 2 -- the conversational AI coach. After this plan, users can chat with the AI, generate workouts, and log sets. The workout VIEW (rendering the generated workout with rest timer and gym UX) comes in Plan 02.

Output: Working chat interface with streaming AI responses, persistent messages, workout generation, freeform logging, coaching profile management, and mobile-first dark theme.
</objective>

<execution_context>
@/home/mcook/.claude/get-shit-done/workflows/execute-plan.md
@/home/mcook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ai-coaching-loop/02-RESEARCH.md
@.planning/phases/01-validation-and-foundation/01-02-SUMMARY.md
@src/server/db/schema.ts
@src/server/db/index.ts
@src/server/index.ts
@src/server/lib/gemini.ts
@src/server/routes/workouts.ts
@src/client/App.tsx
@src/client/main.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database schema changes and server-side coaching libraries</name>
  <files>
    src/server/db/schema.ts
    src/server/lib/coaching.ts
    src/server/lib/guardrails.ts
  </files>
  <action>
**Schema changes in src/server/db/schema.ts:**

Add three things to the existing schema (do NOT remove or modify existing tables):

1. `messages` table for chat history persistence:
   - id: integer primary key autoIncrement
   - role: text notNull ('user' | 'model')
   - content: text notNull
   - workoutId: integer nullable, references workouts.id (linked when a workout was generated from this message)
   - createdAt: text notNull default sql`(CURRENT_TIMESTAMP)`

2. `coachingProfiles` table (single-row, stores user training context):
   - id: integer primary key autoIncrement
   - maxes: text notNull default '{}' (JSON: {"bench": 225, "squat": 315, ...})
   - injuries: text notNull default '[]' (JSON array of strings)
   - equipment: text notNull default '[]' (JSON array of strings)
   - dietaryConstraints: text notNull default '[]' (JSON array, covers DIET-03)
   - preferences: text notNull default '{}' (JSON: {"daysPerWeek": 4, "sessionMinutes": 60})
   - updatedAt: text notNull default sql`(CURRENT_TIMESTAMP)`

3. Add `restSeconds` column to existing `exercises` table:
   - restSeconds: integer nullable (rest between sets in seconds)

Add Drizzle relations for the new tables:
- messagesRelations: messages -> workouts (one, optional via workoutId)
- coachingProfilesRelations: none needed (standalone)

After modifying schema.ts, run `npx drizzle-kit push` to sync the database.

**IMPORTANT:** Use sql`(CURRENT_TIMESTAMP)` for defaults (not string literal -- confirmed Drizzle bug from Phase 1).

**Create src/server/lib/coaching.ts:**

System prompt builder following the exact pattern from 02-RESEARCH.md Pattern 6:
- Export `buildSystemPrompt()` async function
- Load coaching profile from DB via `db.query.coachingProfiles.findFirst()`
- Load last 5 workouts with exercises and sets via `db.query.workouts.findMany()` with `orderBy: [desc(workouts.date)]`, `limit: 5`, `with: { exercises: { with: { sets: true } } }`
- Build system prompt string with: coaching persona, profile data (maxes, injuries, equipment, dietary constraints, preferences), formatted recent workouts, and coaching guidelines
- Export helper `messagesToHistory()` that converts DB messages (role + content) to Gemini SDK `Content[]` format: `{ role: string, parts: [{ text: string }] }`
- Export helper `formatWorkoutForContext()` for formatting a single workout into readable text

**Create src/server/lib/guardrails.ts:**

Weight validation following the exact pattern from 02-RESEARCH.md (Weight Guardrail Validation section):
- EXERCISE_CATEGORIES mapping (bench, squat, deadlift, overhead, row with variant arrays)
- `findMaxForExercise(exerciseName, maxes)` -- fuzzy match exercise name to known max
- Export `validateWorkoutWeights(exercises, maxes)` -- returns array of issues for weights outside 20-120% of known max
  </action>
  <verify>
Run `npx drizzle-kit push` and confirm no errors. Then verify the schema with:
`curl -s http://localhost:3001/api/health` (server still runs after schema push).
Check that `npx tsx -e "import { messages, coachingProfiles } from './src/server/db/schema.js'; console.log('OK')"` compiles without errors.
  </verify>
  <done>
messages and coachingProfiles tables exist in SQLite. exercises table has restSeconds column. coaching.ts exports buildSystemPrompt and messagesToHistory. guardrails.ts exports validateWorkoutWeights. All TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Chat API, profile API, workout generation, and freeform logging endpoints</name>
  <files>
    src/server/routes/chat.ts
    src/server/routes/profile.ts
    src/server/routes/workouts.ts
    src/server/index.ts
  </files>
  <action>
**Create src/server/routes/chat.ts:**

Three endpoints on a Hono sub-app:

1. `POST /send` -- Streaming chat (SSE):
   - Accept JSON body: `{ message: string }`
   - Load all existing messages from DB for history (convert via `messagesToHistory()`)
   - Call `buildSystemPrompt()` for system instruction
   - Create Gemini chat via `ai.chats.create({ model: 'gemini-2.5-flash', config: { systemInstruction: systemPrompt }, history })`
   - Stream response via `streamSSE(c, async (stream) => { ... })` from 'hono/streaming'
   - For each chunk from `chat.sendMessageStream({ message })`, write SSE event: `{ data: JSON.stringify({ type: 'chunk', text }), event: 'message' }`
   - On completion, write final SSE: `{ data: JSON.stringify({ type: 'done', fullText }), event: 'message' }`
   - AFTER streaming completes, persist both user message and AI response to the messages table
   - Follow Pattern 1 from 02-RESEARCH.md exactly

2. `POST /generate-workout` -- Structured workout generation (non-streaming):
   - Accept JSON body: `{ prompt: string }` (e.g., "Generate a push day workout")
   - Call `buildSystemPrompt()` for context
   - Use `ai.models.generateContent()` with `responseMimeType: 'application/json'` and `responseJsonSchema` from a Zod workout plan schema
   - The Zod schema: programName (string), exercises array (name, sets count, reps, weight, restSeconds, notes optional), notes optional
   - Use `z.toJSONSchema()` (NOT zodToJsonSchema -- broken with Zod v4)
   - Parse and validate response with Zod
   - Load coaching profile maxes and run `validateWorkoutWeights()` from guardrails.ts -- include any weight warnings in the response
   - Save the workout to the database using the existing workouts/exercises/sets insert pattern from workouts.ts (transaction-based)
   - Include restSeconds when inserting exercises
   - Persist both the user prompt and AI response as messages (link the AI message to the workout via workoutId)
   - Return the saved workout object + any guardrail warnings

3. `GET /history` -- Load chat history:
   - Return all messages ordered by createdAt ascending
   - Used by the client on page load to restore chat state

**Create src/server/routes/profile.ts:**

Two endpoints:

1. `GET /` -- Return the coaching profile (first row, or default empty profile if none exists)
2. `PUT /` -- Upsert the coaching profile. Accept JSON body with: maxes, injuries, equipment, dietaryConstraints, preferences. If profile exists, update it. If not, insert it. Update the updatedAt timestamp.

**Modify src/server/routes/workouts.ts:**

Add one endpoint:

`POST /:id/log` -- Freeform text workout logging:
- Accept JSON body: `{ text: string }` (e.g., "bench 3x8 at 185, felt easy")
- Use Gemini structured output to parse freeform text into structured data (following Pattern from 02-RESEARCH.md "Freeform Text Set Logging")
- Zod schema for parsed log: exercises array (name, sets array with setNumber/reps/weight/rpe optional), feedback optional
- Use `z.toJSONSchema()` for the response schema
- Update the workout's exercises/sets in the database with the parsed data
- Update the workout's feedback field if feedback was parsed
- Return the parsed structured data

**Modify src/server/index.ts:**

Mount the new routes:
- `app.route('/api/chat', chatRoutes)`
- `app.route('/api/profile', profileRoutes)`

Import chat and profile route modules.

**CRITICAL anti-patterns to avoid:**
- Do NOT use EventSource (GET-only) -- use fetch + ReadableStream on client
- Do NOT stream structured JSON -- use non-streaming generateContent for workout generation
- Do NOT use zodToJsonSchema() -- use z.toJSONSchema() (Zod v4 native)
- Do NOT build system prompt on client -- server-side only
- Do NOT put chat history in URL params -- POST body only
  </action>
  <verify>
Start the server with `npm run dev:server` and test:
1. `curl -X GET http://localhost:3001/api/profile` -- should return empty/default profile (200)
2. `curl -X PUT http://localhost:3001/api/profile -H "Content-Type: application/json" -d '{"maxes":{"bench":185},"injuries":[],"equipment":["barbell","dumbbells"],"dietaryConstraints":[],"preferences":{"daysPerWeek":4}}'` -- should return updated profile (200)
3. `curl -N -X POST http://localhost:3001/api/chat/send -H "Content-Type: application/json" -d '{"message":"Hello coach, what should I work on today?"}'` -- should see SSE event stream with AI response chunks
4. `curl -X GET http://localhost:3001/api/chat/history` -- should return the messages from step 3
5. `curl -X POST http://localhost:3001/api/chat/generate-workout -H "Content-Type: application/json" -d '{"prompt":"Generate a push day workout"}'` -- should return structured workout JSON saved to DB
  </verify>
  <done>
All five API endpoints respond correctly. Chat streaming produces SSE events with Gemini responses. Messages persist to the database. Workout generation returns structured JSON validated by Zod. Profile CRUD works. Freeform logging endpoint parses text into structured workout data.
  </done>
</task>

<task type="auto">
  <name>Task 3: React chat UI with SSE streaming, app shell, and mobile-first styling</name>
  <files>
    src/client/hooks/useChat.ts
    src/client/components/Chat.tsx
    src/client/components/ChatMessage.tsx
    src/client/styles/global.css
    src/client/App.tsx
    src/client/main.tsx
  </files>
  <action>
**Create src/client/hooks/useChat.ts:**

Custom hook following Pattern 3 from 02-RESEARCH.md exactly:
- State: messages array (role: 'user'|'model', text: string, timestamp: number), isStreaming boolean
- `sendMessage(text)`:
  - Add user message to state immediately
  - Add empty AI message placeholder
  - POST to `/api/chat/send` with `{ message: text }`
  - Read response via `res.body.getReader()` + TextDecoder
  - Parse SSE events from the stream (split on '\n\n', find 'data: ' lines, JSON.parse)
  - For 'chunk' events: append text to the last message in state
  - For 'done' events: streaming complete
  - Set isStreaming false in finally block
  - AbortController support for cancellation via `abortRef`
- `generateWorkout(prompt)`:
  - POST to `/api/chat/generate-workout` with `{ prompt }`
  - Return the structured workout response (not streaming)
  - Add both prompt and response summary as messages to local state
- `loadHistory()`:
  - GET `/api/chat/history` on mount
  - Convert DB messages to local state format
  - Called in useEffect on mount
- Return: { messages, sendMessage, generateWorkout, isStreaming }

**Create src/client/components/ChatMessage.tsx:**

Single message bubble component:
- Props: role ('user' | 'model'), text (string), timestamp (number)
- User messages: right-aligned, accent color background
- AI messages: left-aligned, surface color background
- Render text with basic markdown-like formatting (bold with **, newlines as <br />)
- Show timestamp in subtle text below message

**Create src/client/components/Chat.tsx:**

Full chat interface:
- Uses useChat() hook
- Message list area (scrollable, flex-grow) with ChatMessage components
- Auto-scroll to bottom on new messages (useRef + scrollIntoView)
- Input bar at bottom (sticky): text input + send button
- Send on Enter key (not Shift+Enter which inserts newline)
- Disable input while isStreaming
- "Generate Workout" button in the input area or as a special action
- Show a subtle loading indicator during streaming (pulsing dot or similar CSS-only animation)

**Create src/client/styles/global.css:**

Mobile-first dark theme following the exact CSS from 02-RESEARCH.md (Pattern: Mobile-First CSS Base):
- CSS custom properties for colors (dark theme), spacing, tap targets (48px min), font sizes, border radius
- Reset styles (box-sizing, margin, padding)
- html/body: 100% height, system-ui font, dark background
- .chat-container: flex column, 100dvh
- .chat-messages: flex 1, overflow-y auto, padding, -webkit-overflow-scrolling touch
- .chat-input-bar: sticky bottom, surface background, border-top
- button/.tap-target: min 48px height/width, touch-action manipulation
- .rest-timer: large centered font (64px), tabular-nums
- Desktop enhancement: @media (min-width: 768px) grid layout

**Update src/client/App.tsx:**

Replace the health-check-only shell with a tabbed app layout:
- Two tabs at the top or bottom: "Chat" and "Workout"
- Simple state-based tab switching (useState for activeTab)
- Chat tab renders the Chat component
- Workout tab renders a placeholder (WorkoutView comes in Plan 02)
- Tab bar should use large tap targets (48px) for gym use
- Import and apply global.css

**Update src/client/main.tsx:**

Import global.css: `import './styles/global.css'`
Ensure the CSS is loaded before React renders.

**CRITICAL implementation notes:**
- Use fetch + ReadableStream for SSE (NOT EventSource -- it only supports GET)
- Use 100dvh (NOT 100vh) for mobile viewport height
- Minimum 48px tap targets everywhere
- Dark theme is default (gym-friendly)
- Auto-scroll chat to bottom on new messages
  </action>
  <verify>
1. Run `npm run dev:client` and `npm run dev:server`
2. Open http://localhost:5173 in browser
3. Verify dark theme with mobile-first styling loads
4. Type a message in the chat input and press Enter
5. Verify the AI response streams in word-by-word (not all at once)
6. Refresh the page -- verify chat history reloads from the database
7. Click "Generate Workout" or type a workout request -- verify structured workout is returned
8. Open browser DevTools, switch to mobile viewport (iPhone SE or similar) -- verify layout works at 375px width with proper tap targets
  </verify>
  <done>
Chat interface renders with dark theme. User can type messages and see streaming AI responses. Messages persist across page refresh. Generate workout action produces structured workout data. Mobile viewport shows proper layout with 48px tap targets. Tab navigation between Chat and Workout views works (Workout tab shows placeholder).
  </done>
</task>

</tasks>

<verification>
1. Server starts without errors: `npm run dev:server`
2. Client builds and serves: `npm run dev:client`
3. Chat streaming works end-to-end: type message -> see streaming response -> persists in DB
4. Workout generation: request workout -> receive structured JSON -> saved to DB with exercises/sets
5. Profile management: create/update coaching profile via API
6. Freeform logging: POST text to workout log endpoint -> parsed into structured data
7. Chat history survives page refresh
8. Mobile-first dark theme renders correctly at 375px viewport width
9. All tap targets are minimum 48px
</verification>

<success_criteria>
- User can have a multi-turn conversation with the AI coach via streaming chat
- AI responses appear word-by-word (SSE streaming, not batch)
- Chat messages are stored in the messages table and reload on page refresh
- Structured workout generation produces valid exercises/sets/reps/weight/rest data
- Weight guardrails flag unreasonable weights against coaching profile
- Coaching profile CRUD works (maxes, injuries, equipment, dietary constraints)
- Freeform text logging parses into structured workout data
- Dark theme with mobile-first responsive design
- 48px minimum tap targets for gym use
</success_criteria>

<output>
After completion, create `.planning/phases/02-ai-coaching-loop/02-01-SUMMARY.md`
</output>
