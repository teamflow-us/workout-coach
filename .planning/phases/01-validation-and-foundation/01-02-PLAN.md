---
phase: 01-validation-and-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/server/index.ts
  - src/server/routes/workouts.ts
  - src/server/routes/health.ts
  - src/server/db/schema.ts
  - src/server/db/index.ts
  - src/server/lib/gemini.ts
  - src/client/index.html
  - src/client/main.tsx
  - src/client/App.tsx
  - drizzle.config.ts
  - vite.config.ts
  - package.json
  - tsconfig.json
autonomous: true

must_haves:
  truths:
    - "Hono backend serves API routes on a local port"
    - "Gemini API key is loaded server-side from .env and never exposed to the client"
    - "SQLite database accepts workout data through a POST endpoint and returns it through a GET endpoint"
    - "Workout data model supports workouts, exercises, and sets with proper foreign key relationships"
    - "React app renders in the browser and can reach the API"
  artifacts:
    - path: "src/server/index.ts"
      provides: "Hono app entry point with route mounting, CORS, and static file serving"
      exports: ["default"]
    - path: "src/server/routes/workouts.ts"
      provides: "Workout CRUD API (GET list, GET by id, POST create)"
      exports: ["default"]
    - path: "src/server/routes/health.ts"
      provides: "Health check endpoint returning server status"
      exports: ["default"]
    - path: "src/server/db/schema.ts"
      provides: "Drizzle schema for workouts, exercises, and sets tables"
      exports: ["workouts", "exercises", "sets"]
      contains: "sqliteTable"
    - path: "src/server/db/index.ts"
      provides: "Database connection and Drizzle instance"
      exports: ["db"]
    - path: "src/server/lib/gemini.ts"
      provides: "Gemini API client wrapper with key loaded from env"
      exports: ["ai"]
    - path: "src/client/App.tsx"
      provides: "React shell with basic routing placeholder"
    - path: "drizzle.config.ts"
      provides: "Drizzle Kit configuration for SQLite"
  key_links:
    - from: "src/server/routes/workouts.ts"
      to: "src/server/db/index.ts"
      via: "import { db } from '../db'"
      pattern: "import.*db.*from"
    - from: "src/server/routes/workouts.ts"
      to: "src/server/db/schema.ts"
      via: "import { workouts, exercises, sets } from '../db/schema'"
      pattern: "import.*workouts.*schema"
    - from: "src/server/index.ts"
      to: "src/server/routes/workouts.ts"
      via: "app.route('/api/workouts', workoutRoutes)"
      pattern: "app\\.route.*workouts"
    - from: "src/server/lib/gemini.ts"
      to: ".env GEMINI_API_KEY"
      via: "process.env.GEMINI_API_KEY"
      pattern: "process\\.env\\.GEMINI_API_KEY"
---

<objective>
Stand up the full-stack skeleton: Hono backend with workout CRUD API, SQLite database with Drizzle ORM schema for workouts/exercises/sets, Gemini API client wrapper, and a minimal React shell. This is the platform everything in Phase 2+ builds on.

Purpose: Phase 2 (AI coaching loop) needs a working API and database to store workouts. Phase 3 (RAG) needs the Gemini client wrapper. Building the skeleton now means Phase 2 can focus entirely on the coaching features.
Output: Running Hono server with workout API endpoints, SQLite database with schema applied, React app that loads in the browser.
</objective>

<execution_context>
@/home/mcook/.claude/get-shit-done/workflows/execute-plan.md
@/home/mcook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-validation-and-foundation/01-CONTEXT.md
@.planning/phases/01-validation-and-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install infrastructure dependencies and configure build tooling</name>
  <files>package.json, tsconfig.json, drizzle.config.ts, vite.config.ts</files>
  <action>
Install the remaining dependencies needed for the full-stack skeleton. If package.json already exists from Plan 01-01, add to it. If not, initialize fresh.

1. Install backend dependencies:
   ```
   npm install hono @hono/node-server drizzle-orm better-sqlite3 dotenv
   npm install -D drizzle-kit @types/better-sqlite3
   ```
   Note: `@google/genai`, `zod`, `zod-to-json-schema`, `typescript`, `tsx`, and `@types/node` may already be installed from Plan 01-01. Check first, only install what's missing.

2. Install frontend dependencies:
   ```
   npm install react react-dom
   npm install -D vite @vitejs/plugin-react @types/react @types/react-dom
   ```

3. Update tsconfig.json to include JSX support:
   - Add `"jsx": "react-jsx"` to compilerOptions
   - Ensure `"include"` covers both `src/**/*` and `scripts/**/*`

4. Create drizzle.config.ts:
   ```typescript
   import { defineConfig } from 'drizzle-kit'
   export default defineConfig({
     dialect: 'sqlite',
     schema: './src/server/db/schema.ts',
     out: './drizzle',
     dbCredentials: { url: 'file:./workout.db' },
   })
   ```

5. Create vite.config.ts:
   ```typescript
   import { defineConfig } from 'vite'
   import react from '@vitejs/plugin-react'
   export default defineConfig({
     plugins: [react()],
     root: 'src/client',
     build: { outDir: '../../dist/client' },
     server: {
       proxy: { '/api': 'http://localhost:3001' }
     },
   })
   ```

6. Add npm scripts to package.json:
   - `"dev:server": "npx tsx watch src/server/index.ts"` -- run backend with auto-reload
   - `"dev:client": "npx vite --config vite.config.ts"` -- run Vite dev server
   - `"dev": "concurrently \"npm run dev:server\" \"npm run dev:client\""` -- or just document running both manually
   - `"db:push": "npx drizzle-kit push"` -- apply schema to SQLite
   - `"db:generate": "npx drizzle-kit generate"` -- generate migration files
   - `"build": "npx vite build --config vite.config.ts && npx tsc --project tsconfig.json"` -- production build

Do NOT install concurrently as a dependency — just document running server and client in separate terminals. Keep it simple.
  </action>
  <verify>
`npm ls hono drizzle-orm better-sqlite3 react vite` shows all installed.
`cat drizzle.config.ts` shows the Drizzle config.
`cat vite.config.ts` shows the Vite config with proxy.
`npm run db:push --dry-run 2>&1 || true` does not throw a "script not found" error.
  </verify>
  <done>All infrastructure dependencies installed, build tooling configured (Drizzle, Vite, TypeScript), npm scripts defined.</done>
</task>

<task type="auto">
  <name>Task 2: Create database schema, API routes, and Gemini client</name>
  <files>src/server/db/schema.ts, src/server/db/index.ts, src/server/lib/gemini.ts, src/server/routes/workouts.ts, src/server/routes/health.ts, src/server/index.ts, src/client/index.html, src/client/main.tsx, src/client/App.tsx</files>
  <action>
Build the complete server and minimal client. Create all directories as needed (`src/server/db/`, `src/server/routes/`, `src/server/lib/`, `src/client/`).

**1. src/server/db/schema.ts — Drizzle schema**

Define three tables following the research patterns:

```
workouts: id (PK auto), date (text, not null, ISO format), programName (text, nullable), notes (text, nullable), feedback (text, nullable), createdAt (text, not null, default CURRENT_TIMESTAMP)

exercises: id (PK auto), workoutId (FK -> workouts.id, not null), name (text, not null), order (integer, not null)

sets: id (PK auto), exerciseId (FK -> exercises.id, not null), setNumber (integer, not null), reps (integer, nullable), weight (real, nullable), rpe (real, nullable), notes (text, nullable)
```

Also define Drizzle relations for query API support:
- workouts has many exercises
- exercises belongs to workouts, has many sets
- sets belongs to exercises

**2. src/server/db/index.ts — Database connection**

- Import `better-sqlite3` and create a Database instance pointing to `workout.db`
- Import `drizzle` from `drizzle-orm/better-sqlite3`
- Create and export `db` with the schema for relational queries
- Import `dotenv/config` at the top for env loading

**3. src/server/lib/gemini.ts — Gemini client wrapper**

- Import `GoogleGenAI` from `@google/genai`
- Read `GEMINI_API_KEY` from `process.env`
- Throw a clear error if the key is missing: "GEMINI_API_KEY not set in environment"
- Export the `ai` instance (GoogleGenAI)
- Export a helper function `countTokens(text: string, model?: string)` that calls `ai.models.countTokens()`
- This is a thin wrapper — Phase 2 will add coaching-specific functions

**4. src/server/routes/health.ts — Health check**

- GET `/` returns `{ status: 'ok', timestamp: new Date().toISOString() }`

**5. src/server/routes/workouts.ts — Workout CRUD**

Implement these endpoints:

- `GET /` — List all workouts, ordered by date descending. Return an array of workout objects (id, date, programName, notes, feedback, createdAt).
- `GET /:id` — Get a single workout by ID with its exercises and sets (use Drizzle relational query with `{ with: { exercises: { with: { sets: true } } } }`). Return 404 if not found.
- `POST /` — Create a new workout. Accept JSON body: `{ date: string, programName?: string, notes?: string, exercises?: Array<{ name: string, order: number, sets?: Array<{ setNumber: number, reps?: number, weight?: number, rpe?: number, notes?: string }> }> }`. Insert the workout, then exercises, then sets in a transaction. Return the created workout with 201 status.

Use Zod for request body validation on POST. Return proper error responses (400 for invalid body, 404 for not found, 500 for server errors).

**6. src/server/index.ts — Hono app entry**

- Import `serve` from `@hono/node-server`
- Import `Hono` from `hono` and `cors` from `hono/cors`
- Import `serveStatic` from `@hono/node-server/serve-static`
- Import `dotenv/config` for env loading (must be first import)
- Mount health route at `/api/health`
- Mount workout routes at `/api/workouts`
- Apply CORS middleware to `/api/*`
- Serve static files from `./dist/client` for `/*` (production React build)
- SPA fallback: serve `./dist/client/index.html` for unmatched GET routes
- Serve on port 3001
- Print "Server running on http://localhost:3001" on startup

**7. React shell (minimal — just proves the frontend works)**

src/client/index.html:
- Standard HTML5 boilerplate
- `<div id="root"></div>`
- `<script type="module" src="./main.tsx"></script>`

src/client/main.tsx:
- Import React, ReactDOM
- Import App component
- Render `<App />` into the root div

src/client/App.tsx:
- Simple functional component
- Show "William Workout" heading
- Fetch from `/api/health` on mount and display the status
- This proves the client can reach the server through the Vite proxy

**8. Apply the database schema:**

Run `npx drizzle-kit push` to create the SQLite tables.

**9. Start the server and verify the API:**

Run `npx tsx src/server/index.ts` and test with curl:
- `curl http://localhost:3001/api/health` — should return `{ status: "ok" }`
- `curl -X POST http://localhost:3001/api/workouts -H 'Content-Type: application/json' -d '{"date":"2026-02-21","programName":"Push Day A","exercises":[{"name":"Bench Press","order":1,"sets":[{"setNumber":1,"reps":8,"weight":185}]}]}'` — should return 201 with the created workout
- `curl http://localhost:3001/api/workouts` — should return array containing the workout just created
- `curl http://localhost:3001/api/workouts/1` — should return the workout with exercises and sets nested

Kill the server after verification.
  </action>
  <verify>
`npx drizzle-kit push` completes without errors (tables created in workout.db).
Start server with `npx tsx src/server/index.ts &`, then:
- `curl -s http://localhost:3001/api/health | grep ok` returns a match.
- `curl -s -X POST http://localhost:3001/api/workouts -H 'Content-Type: application/json' -d '{"date":"2026-02-21","programName":"Test","exercises":[{"name":"Squat","order":1,"sets":[{"setNumber":1,"reps":5,"weight":225}]}]}' | grep id` returns a match (workout created with an id).
- `curl -s http://localhost:3001/api/workouts/1 | grep exercises` returns a match (nested exercises present).
Kill the server background process.
  </verify>
  <done>
Hono backend running with health and workout CRUD endpoints. SQLite database with workouts/exercises/sets schema applied. Gemini client wrapper configured. React shell created. Workout data round-trips through POST -> GET with nested exercises and sets.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `curl http://localhost:3001/api/health` returns `{ status: "ok" }`
2. POST a workout with exercises and sets, GET it back with all nested data intact
3. `workout.db` exists and contains workouts, exercises, sets tables
4. `src/server/lib/gemini.ts` exports a configured Gemini client using the env key
5. React shell loads in the browser (via Vite dev server) and displays the health check response
6. No secrets in client-facing code (grep for GEMINI_API_KEY in src/client/ returns nothing)
</verification>

<success_criteria>
- Health endpoint responds with 200 and JSON status
- Workout POST creates a workout with exercises and sets, returns 201
- Workout GET /:id returns nested exercises and sets
- Workout GET / lists all workouts
- SQLite database file exists with correct schema
- Gemini API key is server-side only (not in any client file)
- React app renders and fetches from the API
</success_criteria>

<output>
After completion, create `.planning/phases/01-validation-and-foundation/01-02-SUMMARY.md`
</output>
